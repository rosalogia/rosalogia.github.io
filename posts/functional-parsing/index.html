<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Over the past few months, after learning about parser combinators in Joachim Breitner&amp;rsquo;s Haskell course, I&amp;rsquo;ve found myself needing or wanting to approach a problem by writing a parser more often than I had ever expected to. Each time, I&amp;rsquo;m amazed and satisfied by the simplicity and declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting and much less repetitive." />
<meta name="keywords" content=", functional-programming, fsharp, dotnet, fparsec" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="/posts/functional-parsing/" />


    <title>
        
            Parsing Programming Languages with FParsec :: Ambika Eshwar  â€” Functional Programming Enthusiast and Leftist
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.d1ea4af8fd04fb24a4f8b882ea54bd04eb245427ca4baf527c81a5dab071410b.css">






<meta itemprop="name" content="Parsing Programming Languages with FParsec">
<meta itemprop="description" content="Over the past few months, after learning about parser combinators in Joachim Breitner&rsquo;s Haskell course, I&rsquo;ve found myself needing or wanting to approach a problem by writing a parser more often than I had ever expected to. Each time, I&rsquo;m amazed and satisfied by the simplicity and declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting and much less repetitive."><meta itemprop="datePublished" content="2020-12-02T05:09:00-05:00" />
<meta itemprop="dateModified" content="2020-12-02T05:09:00-05:00" />
<meta itemprop="wordCount" content="4375"><meta itemprop="image" content=""/>
<meta itemprop="keywords" content="functional-programming,fsharp,dotnet,fparsec," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content=""/>

<meta name="twitter:title" content="Parsing Programming Languages with FParsec"/>
<meta name="twitter:description" content="Over the past few months, after learning about parser combinators in Joachim Breitner&rsquo;s Haskell course, I&rsquo;ve found myself needing or wanting to approach a problem by writing a parser more often than I had ever expected to. Each time, I&rsquo;m amazed and satisfied by the simplicity and declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting and much less repetitive."/>



    <meta property="og:title" content="Parsing Programming Languages with FParsec" />
<meta property="og:description" content="Over the past few months, after learning about parser combinators in Joachim Breitner&rsquo;s Haskell course, I&rsquo;ve found myself needing or wanting to approach a problem by writing a parser more often than I had ever expected to. Each time, I&rsquo;m amazed and satisfied by the simplicity and declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting and much less repetitive." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/functional-parsing/" /><meta property="og:image" content=""/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-02T05:09:00-05:00" />
<meta property="article:modified_time" content="2020-12-02T05:09:00-05:00" /><meta property="og:site_name" content="Ambika Eshwar" />







    <meta property="article:published_time" content="2020-12-02 05:09:00 -0500 EST" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/rosalogia</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about">About</a></li><li><a href="/apps">Apps</a></li><li><a href="/posts">Blog</a></li><li><a href="/resources">Resources</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        21 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="/posts/functional-parsing/">Parsing Programming Languages with FParsec</a>
      </h1>
        <hr />
        <aside id="toc">
          <div class="toc-title">Table of Contents</div>
          <nav id="TableOfContents">
  <ul>
    <li><a href="#representing-an-ast">Representing an AST</a></li>
    <li><a href="#parsing">Parsing</a>
      <ul>
        <li><a href="#values">Values</a></li>
        <li><a href="#expressions">Expressions</a></li>
        <li><a href="#statements">Statements</a></li>
      </ul>
    </li>
    <li><a href="#tying-it-all-together">Tying it All Together</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#errata">Errata</a></li>
  </ul>
</nav>
        </aside>
        <hr />

      

      <div class="post-content">
        <p>Over the past few months, after learning about parser combinators in Joachim Breitner&rsquo;s
<a href="https://www.seas.upenn.edu/~cis194/fall16/">Haskell course</a>, I&rsquo;ve found myself needing or wanting to approach a problem
by writing a parser more often than I had ever expected to. Each time, I&rsquo;m amazed and satisfied by the simplicity and
declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and
readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting
and much less repetitive.</p>
<p>My first use-case for parser-combinators outside of the aforementioned Haskell course was parsing a &ldquo;pseudocode&rdquo; language
used by my university to teach the first few weeks of our intro CS course. The irony in this &ldquo;pseudocode&rdquo; was that its syntax
was so strictly defined that it sort of transcended its label, and I figured I&rsquo;d be able to create a parser that successfully
transformed correct &ldquo;pseudocode&rdquo; into an AST. Once I finished writing a parser, I figured it wouldn&rsquo;t be too difficult to
implement an interpreter as well, and indeed this too was within reach. I enjoyed the project a lot, and in this post and
the post that will follow (in which we will implement an interpreter), I wanted to share the process as a more exciting and
slightly more challenging alternative to the typical JSON parsing tutorial that most parser-combinators already have.</p>
<p>Note that the language we will be writing a parser for in this post is a language of our own creation! If you disagree with
me on how the syntax of the language should appear and feel confident enough in your understanding of parser-combinators,
feel free to experiment and create a language syntax that&rsquo;s more akin to your preferences. Another thing to note is that this tutorial
is not quite suited to those who are unfamiliar with F# and functional programming. I would also recommend doing some more basic
reading on parser-combinators before approaching this post, as I try not to spend time on what they are but rather on explaining
how they can be used in a cool way. The FParsec documentation&rsquo;s tutorial is very good and very helpful, as is Scott Wlaschin&rsquo;s
series on <a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Understanding Parser Combinators</a>.</p>
<h2 id="representing-an-ast">Representing an AST</h2>
<p>The goal of a parser is to give structure and meaning to the information it receives. When dealing with source code for
programming languages, we often want to give structure and meaning to code by translating it into an &ldquo;abstract syntax tree.&rdquo;
Modelling an AST in F# is pretty easy using Algebraic Data Types. We simply need to create types and constructors that
correspond to every type of thing that the source code for a program in our language might contain.</p>
<p>A good place to start in representing the syntax of our language is values, such as integers, strings, and booleans. In this
series of posts, we will make it our goal to be able to parse and eventually interpret an implementation of FizzBuzz
in our language, but not much more. For this reason, we will not be concerned with parsing floating point numbers, arrays,
etc. Integers, strings, and booleans will do.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Int <span style="color:#66d9ef">of</span> int
    <span style="color:#f92672">|</span> Str <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
    <span style="color:#f92672">|</span> Bool <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">bool</span>
</code></pre></div><p>From this point on, we are &ldquo;thinking upwards.&rdquo; Once we have succeeded in representing one foundational structure, we can ask
ourselves what kinds of structures we&rsquo;ve enabled ourselves to represent by defining this one. Now that we have a way to represent
values in our AST, we might want to represent expressions as well. The various forms that expressions take in most programming
languages tend to be:</p>
<ul>
<li>Literals (values)</li>
<li>Variables (which evaluate down to values)</li>
<li>Operations (which chain together expressions and ultimately evaluate down to values)</li>
</ul>
<p>Defining values gives us a way to represent both literals and variables, but to represent operations we need a way to represent
operators as well. Before creating an Expression type, we will define an Operator type like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Operator</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Add <span style="color:#75715e">// Arithmetic operators
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Sub
    <span style="color:#f92672">|</span> Mult
    <span style="color:#f92672">|</span> Div
    <span style="color:#f92672">|</span> Mod
    <span style="color:#f92672">|</span> Gt <span style="color:#75715e">// Comparison operators
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Lt
    <span style="color:#f92672">|</span> Gte
    <span style="color:#f92672">|</span> Lte
    <span style="color:#f92672">|</span> Eq <span style="color:#75715e">// Equality operators
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Neq
    <span style="color:#f92672">|</span> And <span style="color:#75715e">// Boolean operators
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Or
    <span style="color:#f92672">|</span> Sconcat <span style="color:#75715e">// String concatenation
</span></code></pre></div><p>And now, we can define an <code>Expr</code> type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Expr</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Literal <span style="color:#66d9ef">of</span> Value
    <span style="color:#f92672">|</span> Variable <span style="color:#66d9ef">of</span> name<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span>
    <span style="color:#75715e">// The Expr type is recursive, as operations
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// can consist of expressions
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Operation <span style="color:#66d9ef">of</span> <span style="color:#f92672">(</span>Expr <span style="color:#f92672">*</span> Operator <span style="color:#f92672">*</span> Expr<span style="color:#f92672">)</span>
</code></pre></div><p>Believe it or not, we are almost done building types to represent our AST. All that&rsquo;s left is a type to represent <em>statements</em>.
Because all we are aiming to do with this language is parse and interpret FizzBuzz, we will avoid implementing functions in our
language and will only implement some of the most basic imperative constructs:</p>
<ul>
<li>Printing output</li>
<li>Assigning values to variables</li>
<li>If/Else conditionals</li>
<li>While loops</li>
</ul>
<p>This will make for a very simple language, but we will be able to do some fun things with it once we&rsquo;re done. We can
represent statements by pairing them with the information they need to execute. E.g. Print requires an expression to output,
Set (as in set equal to) requires a variable name and an expression to pair that name with, etc.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Statement</span> <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> Print <span style="color:#66d9ef">of</span> Expr
    <span style="color:#f92672">|</span> Set <span style="color:#66d9ef">of</span> name<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> value<span style="color:#f92672">:</span>Expr
    <span style="color:#f92672">|</span> If <span style="color:#66d9ef">of</span> condition<span style="color:#f92672">:</span>Expr <span style="color:#f92672">*</span> body<span style="color:#f92672">:</span>Block <span style="color:#f92672">*</span> <span style="color:#66d9ef">else</span><span style="color:#f92672">:</span>Block option
    <span style="color:#f92672">|</span> While <span style="color:#66d9ef">of</span> condition<span style="color:#f92672">:</span>Expr <span style="color:#f92672">*</span> body<span style="color:#f92672">:</span>Block
<span style="color:#f92672">and</span> Block <span style="color:#f92672">=</span> Statement <span style="color:#66d9ef">list</span>
</code></pre></div><p>We have defined a Block type in a mutually recursive fashion with the Statement type to represent lists of statements, which
constitute the bodies of ifs and whiles in our AST, as well as our program as a whole.</p>
<p>With these types defined, we can begin writing parsers that will output values of these types, and eventually we can
write a program that executes certain instructions based on data that comes in the form of an AST.</p>
<h2 id="parsing">Parsing</h2>
<h3 id="values">Values</h3>
<p>Now that we have a meaningful way to represent parsed source code, we can begin writing parsers that output values
of the types in our AST representation.</p>
<p>I like to start by defining some convenient combinators which I use frequently that FParsec doesn&rsquo;t provide on its own.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pword s <span style="color:#f92672">=</span> pstring s <span style="color:#f92672">.&gt;&gt;</span> spaces

<span style="color:#75715e">// A combinator that transforms a parser by requiring that it
</span><span style="color:#75715e">// be wrapped in parentheses
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> parens p <span style="color:#f92672">=</span> between <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;(&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;)&#34;</span><span style="color:#f92672">)</span> p
</code></pre></div><p>The <code>.&gt;&gt;</code> operator returns the result of the parser on the left and discards the result of the parser on the right.</p>
<p>Now we can slowly begin implementing parsers for all the things in our AST, beginning with Values which may be
integers, strings, or booleans.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pbool<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    pword <span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#f92672">&lt;|&gt;</span> pword <span style="color:#e6db74">&#34;false&#34;</span>
    <span style="color:#f92672">|&gt;&gt;</span> <span style="color:#66d9ef">function</span>
        <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#f92672">-&gt;</span> Bool <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;false&#34;</span> <span style="color:#f92672">-&gt;</span> Bool <span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>

<span style="color:#75715e">// FParsec defines the pint32 parser.
</span><span style="color:#75715e">// We simply cast its result to an int
</span><span style="color:#75715e">// then construct an Integer Value from it
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pint<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> pint32 <span style="color:#f92672">|&gt;&gt;</span> int <span style="color:#f92672">|&gt;&gt;</span> Int
</code></pre></div><p>The <code>&lt;|&gt;</code> operator is the &ldquo;or&rdquo; operator. If the parser on the left fails, it will use the parser on the right instead. If both
fail, we get a parsing error. Whether the parsed string is &ldquo;true&rdquo; or &ldquo;false&rdquo;, we can easily pass it to our value constructor to
convert it to a Bool Value. When we want to try several parsers, using the <code>&lt;|&gt;</code> operator can become inconvenient. In those
situations, the <code>choice</code> combinator exists, and operates on a list of parsers of the same type. We will see how it&rsquo;s useful later,
but know that we could have just as well done <code>choice [ pword &quot;true&quot; ; pword &quot;false&quot; ]</code> to achieve the same effect as using the
&ldquo;or&rdquo; operator here.</p>
<p>The <code>|&gt;&gt;</code> operator lets us pipe the result of our parser to a function that normally operates on the type of our result,
then returns whatever value it produces into a Parser value. In this case, we have to pipe the result of parsing the string
&ldquo;true&rdquo; or &ldquo;false&rdquo; to a pattern match where we match each string to a corresponding Bool Value.</p>
<p>Note that when we use parser-combinators, we do not actually receive values in their original or &ldquo;regular&rdquo; types until we finally run our
parser with a variant of the <code>run</code> function defined by FParsec. Until then, you will notice that our values are always in
the form <code>Parser&lt;Type, Unit&gt;</code>. This is done in accordance with a functional design pattern that
<a href="https://fsharpforfunandprofit.com/posts/elevated-world/">Scott Wlaschin</a> explains more carefully on his site than I can in
this post.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pstringliteral<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    <span style="color:#75715e">// This line returns a list of chars, which we have to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// turn into a string before turning into a Str Value
</span><span style="color:#75715e"></span>    pchar <span style="color:#e6db74">&#39;\&#34;&#39;</span> <span style="color:#f92672">&gt;&gt;.</span> manyCharsTill anyChar <span style="color:#f92672">(</span>pchar <span style="color:#e6db74">&#39;\&#34;&#39;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">|&gt;&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|&gt;&gt;</span> Str
    <span style="color:#75715e">// Discard the spaces at the end
</span><span style="color:#75715e"></span>    <span style="color:#f92672">.&gt;&gt;</span> spaces
</code></pre></div><p>In order to parse any sequence of characters between a pair of quotes, we first parse the opening quote and discard it, then
use the <code>manyCharsTill</code> combinator to parse all the remaining characters up until the closing quote (which is discarded).</p>
<p>Note that the <code>&gt;&gt;.</code> operator is very similar to the <code>.&gt;&gt;</code> operator. In this case, the value on the left of the operator is
discarded. A good way to think about it is that whatever is on the side of the <code>.</code> is what gets kept. The operators <code>&gt;&gt;</code> and
<code>.&gt;&gt;.</code> also exist, for when you only want to discard twice in a row or when you want to keep two parsed values in a row, in which
case you&rsquo;ll receive a tuple.</p>
<p><code>manyCharsTill</code> takes two parsers. The former is run until the latter is eventually matched, at which point it stops.</p>
<p>Now that we have defined parsers for the three types of values that might be represented in our AST, we want to create
a <code>pvalue</code> parser that combines all three of them. To do this, we will use <code>choice</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pvalue<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    choice <span style="color:#f92672">[</span>
        pint
        pstringliteral
        pbool
    <span style="color:#f92672">]</span>
</code></pre></div><h4 id="running-and-testing-parsers">Running and Testing Parsers</h4>
<p>As we work on our parser, it&rsquo;s a good idea to test the parsers you build individually as you progress. The easiest way
to do this is to create a console application that references FParsec and uses the provided <code>run</code> function on a parser
and a string. Be aware that it returns a result type, so you can define a test function like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> test parser strInput <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">match</span> run parser strInput <span style="color:#66d9ef">with</span>
    <span style="color:#75715e">// Assuming your parser returns something
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// that can be printed. For our purposes,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// %O is usually enough. 
</span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Success <span style="color:#f92672">(</span>result<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%O&#34;</span> result
    <span style="color:#f92672">|</span> Failure <span style="color:#f92672">(</span>error<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%s&#34;</span> error
</code></pre></div><p>Also be aware that FParsec&rsquo;s parsing errors are extremely informative and helpful!</p>
<h3 id="expressions">Expressions</h3>
<p>Going in the same order in which we defined types in our AST representation, we now want to implement expression parsers
that make use of our value parser.</p>
<p>We can easily start by writing a parser for <code>Literal</code>s, since all they require is a <code>Value</code> which we can already parse.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pliteral<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> pvalue <span style="color:#f92672">|&gt;&gt;</span> Literal
</code></pre></div><p>Writing a variable parser is slightly more difficult, but the implementation is largely up to us. I have chosen to make
valid variable names begin with letters and contain either letters or numbers. We can implement this rule using the
<code>many1Satisfy2</code> combinator which takes two predicates and parses as many characters as possible so long as</p>
<ul>
<li>The first char must satisfy the first predicate</li>
<li>The remaining chars must satisfy the second predicate</li>
</ul>
<p>Using this convenient combinator, we can write a variable parser that implements the rule above like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pvariable<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    many1Satisfy2 <span style="color:#f92672">(</span>System.Char.IsLetter<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>System.Char.IsLetterOrDigit<span style="color:#f92672">)</span>
    <span style="color:#f92672">|&gt;&gt;</span> Variable
    .<span style="color:#f92672">&gt;&gt;</span> spaces
</code></pre></div><p>The most difficult and convoluted parser to implement is the operation parser. FParsec provides some convenient utilities
to make this task less difficult, but ultimately it is still rather tedious. FParsec includes the
<a href="https://www.quanttec.com/fparsec/reference/operatorprecedenceparser.html#members.OperatorPrecedenceParser"><code>OperatorPrecedenceParser</code></a>
class. This allows us to define a parser for each &ldquo;term&rdquo; of an operation, define operators themselves according to their symbol,
associativity, precedence, and how the parser should handle them, and in return get an operation parser handed to us for a given
type. This is extremely convenient, whereas implementing operator parsing on our own would&rsquo;ve been rather difficult.</p>
<p>Let&rsquo;s begin configuring an <code>OperatorPrecedenceParser</code> for integers, beginning by initialising one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> intOperatorParser <span style="color:#f92672">=</span> OperatorPrecedenceParser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
</code></pre></div><p>Every OperatorPrecedenceParser has an expression parser that gets updated as we further define the OperatorPrecedenceParser by
giving it a term parser and operators to operate on those terms. If at any point we want to parse an operation between two
integers, we will use this parser.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> intExpr <span style="color:#f92672">=</span> intOperatorParser<span style="color:#f92672">.</span>ExpressionParser
</code></pre></div><p>We define the parser for an int &ldquo;term&rdquo;, that is, something that lies on either side of an integer operation (which may be an
integer operation itself, which is why we refer to the intexpr parser in our term parser)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> intTerm <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
    pint <span style="color:#f92672">.&gt;&gt;</span> spaces <span style="color:#f92672">|&gt;&gt;</span> Literal <span style="color:#f92672">&lt;|&gt;</span> pvariable
    parens intExpr
<span style="color:#f92672">]</span>
<span style="color:#75715e">// Assign the term parser we designed to the
</span><span style="color:#75715e">// OperatorPrecedenceParser instance
</span><span style="color:#75715e"></span>intOperatorParser<span style="color:#f92672">.</span>TermParser <span style="color:#f92672">&lt;-</span> intTerm
</code></pre></div><p>The <code>OperatorPrecedenceParser</code> class has an <code>AddOperator</code> method to which we can pass an <code>InfixOperator</code> object (a class also
defined by FParsec) that takes as input the following:</p>
<ul>
<li>A string symbol representing the operator</li>
<li>A parser to run after consuming the operator (usually a white-space parser)</li>
<li>The relative precedence level of the operator as an integer</li>
<li>The associativity of the operator (FParsec provides an Associativity type with constructors Left and Right)</li>
<li>A function that takes two terms and returns a term <code>('TTerm -&gt; 'TTerm -&gt; 'TTerm)</code></li>
</ul>
<p>It can be a little difficult to know how to create every operator we need using this constructor. One thing to note is that
the function that the <code>InfixOperator</code> constructor takes, known as a mapping, will not actually apply an operation to two
terms in our case. Since we are only parsing here, we will take two <code>Expr</code>s in our mapping and return an <code>Operation</code>, which
works because <code>Operation</code>s are <code>Expr</code>s, as are variables and literals. This is, in fact, so simple that it does not need
to change much at all between operators. We can write a simple function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> createOperation op x y <span style="color:#f92672">=</span> Operation <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> op<span style="color:#f92672">,</span> y<span style="color:#f92672">)</span>
</code></pre></div><p>Which we can later partially apply to an <code>Operator</code> to define our mapping. Here is an example of how creating an <code>InfixOperator</code>
might work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp">
<span style="color:#66d9ef">let</span> addition <span style="color:#f92672">=</span> InfixOperator<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;+&#34;</span><span style="color:#f92672">,</span> spaces<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> Associativity.Left<span style="color:#f92672">,</span> createOperation Add<span style="color:#f92672">)</span>
intOperatorParser<span style="color:#f92672">.</span>AddOperator<span style="color:#f92672">(</span>addition<span style="color:#f92672">)</span>
</code></pre></div><p>Now, when the <code>intExpr</code> parser is applied to a string like <code>1 + 3</code>, the AST representation will look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp">Operation <span style="color:#f92672">(</span>
    Literal <span style="color:#f92672">(</span>Int 1<span style="color:#f92672">),</span>
    Add<span style="color:#f92672">,</span>
    Literal <span style="color:#f92672">(</span>Int 3<span style="color:#f92672">)</span>
<span style="color:#f92672">)</span>
</code></pre></div><p>Which we can easily work with later in the interpreting phase.</p>
<p>In order to minimise code repetition, we can employ the following pattern to quickly create and add all the operators we need
for integers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">OperatorDetails</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>  Symbol<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">;</span>
                          Precedence<span style="color:#f92672">:</span> int<span style="color:#f92672">;</span>
                          Operator<span style="color:#f92672">:</span> Operator <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> intOperators <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;+&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Add<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&gt;&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Gt<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Lt<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&gt;=&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Gte<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;=&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Lte<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;==&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Eq<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;!=&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Neq<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;+&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Add<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Sub<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;*&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 3<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Mult<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 3<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Div<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;%&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 3<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Mod<span style="color:#f92672">}</span>
<span style="color:#f92672">]</span>

<span style="color:#66d9ef">let</span> addOperators precedenceParser operatorTable <span style="color:#f92672">=</span>
    operatorTable
    <span style="color:#f92672">|&gt;</span> List.iter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> details <span style="color:#f92672">-&gt;</span>
        <span style="color:#66d9ef">let</span> operator <span style="color:#f92672">=</span>
          InfixOperator<span style="color:#f92672">(</span>
              details<span style="color:#f92672">.</span>Symbol<span style="color:#f92672">,</span>
              spaces<span style="color:#f92672">,</span>
              details<span style="color:#f92672">.</span>Precedence<span style="color:#f92672">,</span>
              Associativity.Left<span style="color:#f92672">,</span>
              createOperation details<span style="color:#f92672">.</span>Operator
          <span style="color:#f92672">)</span>
        precedenceParser<span style="color:#f92672">.</span>AddOperator<span style="color:#f92672">(</span>operator<span style="color:#f92672">))</span>


addOperators intOperatorParser intOperators
</code></pre></div><p>We create a small table of operators for integers, then define a function that iterates over the table and adds each operator
to its <code>OperatorPrecedenceParser</code>. This is a relatively neat way to do what becomes rather ugly otherwise. We need to do the same
thing for strings and booleans, but they have far fewer operations defined over them, so we have slightly less to worry about.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#75715e">// Define similar structures for booleans and strings
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> boolOperatorParser <span style="color:#f92672">=</span> OperatorPrecedenceParser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
<span style="color:#66d9ef">let</span> boolExpr <span style="color:#f92672">=</span> boolOperatorParser<span style="color:#f92672">.</span>ExpressionParser
<span style="color:#66d9ef">let</span> boolTerm <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
    pboolval <span style="color:#f92672">.&gt;&gt;</span> spaces <span style="color:#f92672">|&gt;&gt;</span> Literal
    pvariable
    parens boolExpr
<span style="color:#f92672">]</span>
boolOperatorParser<span style="color:#f92672">.</span>TermParser <span style="color:#f92672">&lt;-</span> boolTerm

<span style="color:#66d9ef">let</span> strOperatorParser <span style="color:#f92672">=</span> OperatorPrecedenceParser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
<span style="color:#66d9ef">let</span> strExpr <span style="color:#f92672">=</span> strOperatorParser<span style="color:#f92672">.</span>ExpressionParser
<span style="color:#75715e">// We want to make sure we can concatenate
</span><span style="color:#75715e">// non-string values with strings, so we
</span><span style="color:#75715e">// accept any literal or variable
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> strTerm <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
    pliteral
    pvariable
    intExpr
    boolExpr
    parens strExpr 
<span style="color:#f92672">]</span>
strOperatorParser<span style="color:#f92672">.</span>TermParser <span style="color:#f92672">&lt;-</span> strTerm
</code></pre></div><p>Now we define their operator tables and add those operators with <code>List.iter</code> as we did for integers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> boolOperators <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;and&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span>  And<span style="color:#f92672">}</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;or&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Or<span style="color:#f92672">}</span>
<span style="color:#f92672">]</span>

<span style="color:#66d9ef">let</span> stringOperators <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;++&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Sconcat<span style="color:#f92672">}</span>
<span style="color:#f92672">]</span>

addOperators boolOperatorParser boolOperators
addOperators strOperatorParser stringOperators
</code></pre></div><p>Now we have a parser for every type of operation, we can define an operation parser much like we defined a value parser earlier:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> poperation <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
    intExpr
    boolExpr
    strExpr
<span style="color:#f92672">]</span>
</code></pre></div><p>And now, since we have a literal parser, a variable parser, and an operation parser, we can define an expression parser:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pexpression <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
    poperation
    pliteral
    pvariable
<span style="color:#f92672">]</span>
</code></pre></div><p>We can finally move on to parsing statements.</p>
<h3 id="statements">Statements</h3>
<p>Something to note before we get started implementing statement parsers is that the <code>Statement</code> type is recursive. The
<code>Expr</code> type is also recursive, but we handled that with the <code>OperatorPrecedenceParser</code> class given to us by FParsec.
The <code>Statement</code> class is recursive because <code>If</code> blocks and <code>While</code> loops must contain statements themselves to be useful.
We will find that before we can create a <code>pstatement</code> parser the way we did with <code>pvalue</code> and <code>poperation</code>, we will need
access to a <code>pstatement</code> parser for use in defining the parsers for if and while. FParsec offers a solution for this as well,
as recursive parsers aren&rsquo;t awfully uncommon.</p>
<p>The solution is the <code>createParserForwardedToRef</code> function, which takes advantage of F#&rsquo;s multi-paradigm nature to simplify
the handling of recursive parsers. Of course, it&rsquo;s all abstracted rather well, so we don&rsquo;t need to worry too much about how
it&rsquo;s implemented to make good use of it. Before we begin implementing statement parsers, we will create the <code>pstatement</code>
parser like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pstatement<span style="color:#f92672">,</span> pstatementref <span style="color:#f92672">=</span> createParserForwardedToRef<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
</code></pre></div><p>Later on, when we wish to parse a statement within a statement parser, we can use <code>pstatement</code>.</p>
<p>Let&rsquo;s parse all our statements in order, starting with print:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pprint<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    pword <span style="color:#e6db74">&#34;print&#34;</span>
    <span style="color:#f92672">&gt;&gt;.</span> parens pexpression
    <span style="color:#f92672">|&gt;&gt;</span> Print
</code></pre></div><p>We&rsquo;re able to use the <code>&gt;&gt;.</code> operator in conjunction with the <code>parens</code> combinator we defined earlier to parse out the expression
within a <code>print(...)</code> statement and pass it to the <code>Print</code> constructor.</p>
<p>Next we&rsquo;ll implement <code>Set</code> which parses variable assignment:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pset<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> identifier <span style="color:#f92672">=</span>
        many1Skip2 <span style="color:#f92672">(</span>System.Char.IsLetter<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>System.Char.IsLetterOrDigit<span style="color:#f92672">)</span>
        <span style="color:#f92672">.&gt;&gt;</span> pword <span style="color:#e6db74">&#34;=&#34;</span>

    identifier <span style="color:#f92672">.&gt;&gt;.</span> pexpression
    <span style="color:#f92672">|&gt;&gt;</span> Set
</code></pre></div><p>Here we define an <code>identifier</code> parser that parses valid names of variables before an equals sign (which gets discarded),
then make use of the <code>.&gt;&gt;.</code> operator to parse both an identifier and an expression and pass the resulting tuple to the <code>Set</code>
constructor.</p>
<p>Before we move on, we&rsquo;ll define a parser called <code>pblock</code> which parses blocks of code between curly braces:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pblock<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement <span style="color:#66d9ef">list</span><span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    between <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;{&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;}&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>many pstatement<span style="color:#f92672">)</span>
</code></pre></div><p>Now we can define parsers for if and while:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pif<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> condition <span style="color:#f92672">=</span> pword <span style="color:#e6db74">&#34;if&#34;</span> <span style="color:#f92672">&gt;&gt;.</span> pexpression
    <span style="color:#66d9ef">let</span> inner <span style="color:#f92672">=</span> pblock
    <span style="color:#66d9ef">let</span> elseBlock <span style="color:#f92672">=</span> pword <span style="color:#e6db74">&#34;else&#34;</span> <span style="color:#f92672">&gt;&gt;.</span> pblock <span style="color:#f92672">|&gt;</span> opt
    
    pipe3 condition inner elseBlock <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> condition inner elseBlock <span style="color:#f92672">-&gt;</span> If <span style="color:#f92672">(</span>condition<span style="color:#f92672">,</span> inner<span style="color:#f92672">,</span> elseBlock<span style="color:#f92672">))</span>
</code></pre></div><p>In the if parser, we first parse a condition by parsing out the &ldquo;if&rdquo; then disposing of it, and keeping the valid expression
that follows. We use <code>pblock</code> to parse the body of the if, and we use FParsec&rsquo;s <code>opt</code> to optionally parse an else block as well.
If there is no else block, this parser returns <code>None</code> which we pass to the <code>If</code> constructor. The parser gets a little ugly
toward the end because we need to use <code>pipe3</code>. Unfortunately there is no operator in FParsec that conveniently performs
the same task as <code>.&gt;&gt;.</code> but returning a triple rather than a tuple. Instead, we must use <code>pipe3</code> which applies 3 given
parsers in order, and then pipes their results to a function that takes 3 inputs. Here we use <code>pipe3</code> to pipe the condition,
if body, and potentially existing else block to the <code>If</code> constructor.</p>
<p>Thankfully, the while parser is much nicer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> pwhile<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> condition <span style="color:#f92672">=</span> pword <span style="color:#e6db74">&#34;while&#34;</span> <span style="color:#f92672">&gt;&gt;.</span> pexpression
    
    condition <span style="color:#f92672">.&gt;&gt;.</span> pblock
    <span style="color:#f92672">|&gt;&gt;</span> While
</code></pre></div><p>We use the same parsing strategy we employed for parsing the condition in the if parser here, while using the same <code>.&gt;&gt;.</code> strategy
for piping to the constructor that we used for <code>pset</code>.</p>
<p>We have now defined all of our statement parsers, but before we can progress, we must complete one last step required by the
<code>pstatement</code> parser that was forwarded to a reference cell. Similar to how we created the <code>pvalue</code> and <code>pexpression</code> parsers,
we assign a <code>choice</code> of the statement parsers we&rsquo;ve written to the <code>pstatementref</code> that was created when we initialised the
<code>pstatement</code> parser:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">do</span> pstatementref <span style="color:#f92672">:=</span> choice <span style="color:#f92672">[</span>
    pprint
    pif
    pwhile
    pset
<span style="color:#f92672">]</span>
</code></pre></div><p>Do not worry if this step confuses you. This quote from the FParsec documentation&rsquo;s JSON parsing tutorial helps demystify it
a little bit:</p>
<blockquote>
<p>The grammar rules for JSON lists and objects are recursive, because any list or object can contain itself any kind of JSON value. Hence, in order to write parsers for the list and object grammar rules, we need a way to refer to the parser for any kind of JSON value, even though we havenâ€™t yet constructed this parser. Like it is so often in computing, we can solve this problem by introducing an extra indirection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> jvalue<span style="color:#f92672">,</span> jvalueRef <span style="color:#f92672">=</span> createParserForwardedToRef<span style="color:#f92672">&lt;</span>Json<span style="color:#f92672">,</span> <span style="color:#66d9ef">unit</span><span style="color:#f92672">&gt;</span>()
</code></pre></div><p>As you might have guessed from the name, <code>createParserForwardedToRef</code> creates a parser (jvalue) that forwards all invocations to the parser in a reference cell (jvalueRef). Initially, the reference cell holds a dummy parser, but since the reference cell is mutable, we can later replace the dummy parser with the actual value parser, once we have finished constructing it.</p>
</blockquote>
<p>You can read the full tutorial <a href="https://www.quanttec.com/fparsec/tutorial.html#parsing-json">here</a>.</p>
<h2 id="tying-it-all-together">Tying it All Together</h2>
<p>At this point we have implemented parsers for everything that appears in the set of types we created to represent our language&rsquo;s
AST. This means that we can write programs in the language we specified and run them through our parser to get an AST as output.
Later on, we can use this generated AST to map code in the source language to F# code to implement an interpreter. For now, let&rsquo;s
write a testing function that will allow us to see how far we&rsquo;ve come.</p>
<p>As explained at an earlier point, FParsec provides a <code>run</code> function and variants of it for running parsers. We specifically
want to run a parser on a file, and what we want to parse is as many statements as we can. FParsec provides a <code>runParserOnFile</code>
function, and we have built a statement parser which we can combine with the <code>many</code> combinator to achieve the effect we&rsquo;re looking
for:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#66d9ef">let</span> parseSourceFile fpath <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">match</span> runParserOnFile <span style="color:#f92672">(</span>many pstatement<span style="color:#f92672">)</span> () fpath System.Text.Encoding.UTF8 <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> Success <span style="color:#f92672">(</span>result<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%A&#34;</span> result
    <span style="color:#f92672">|</span> Failure <span style="color:#f92672">(</span>error<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%s&#34;</span> error
</code></pre></div><p>Now we need a file to test this on. As promised, a FizzBuzz implementation will do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

<span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">100</span> {
    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">15</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        print(<span style="color:#e6db74">&#34;fizzbuzz&#34;</span>)
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
            print(<span style="color:#e6db74">&#34;fizz&#34;</span>)
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
                print(<span style="color:#e6db74">&#34;buzz&#34;</span>)
            } <span style="color:#66d9ef">else</span> {
                print(i)
            }
        }
    }

    i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
}
</code></pre></div><p>Running your parser on this file should result in something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fsharp" data-lang="fsharp"><span style="color:#f92672">[</span>Set <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 1<span style="color:#f92672">));</span>
 While
   <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Lte<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 100<span style="color:#f92672">)),</span>
    <span style="color:#f92672">[</span>If
       <span style="color:#f92672">(</span>Operation
          <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Mod<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 15<span style="color:#f92672">)),</span> Eq<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 0<span style="color:#f92672">)),</span>
        <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Literal <span style="color:#f92672">(</span>Str <span style="color:#e6db74">&#34;fizzbuzz&#34;</span><span style="color:#f92672">))],</span>
        Some
          <span style="color:#f92672">[</span>If
             <span style="color:#f92672">(</span>Operation
                <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Mod<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 3<span style="color:#f92672">)),</span> Eq<span style="color:#f92672">,</span>
                 Literal <span style="color:#f92672">(</span>Int 0<span style="color:#f92672">)),</span> <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Literal <span style="color:#f92672">(</span>Str <span style="color:#e6db74">&#34;fizz&#34;</span><span style="color:#f92672">))],</span>
              Some
                <span style="color:#f92672">[</span>If
                   <span style="color:#f92672">(</span>Operation
                      <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Mod<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 5<span style="color:#f92672">)),</span> Eq<span style="color:#f92672">,</span>
                       Literal <span style="color:#f92672">(</span>Int 0<span style="color:#f92672">)),</span> <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Literal <span style="color:#f92672">(</span>Str <span style="color:#e6db74">&#34;buzz&#34;</span><span style="color:#f92672">))],</span>
                    Some <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">)])])]);</span>
     Set <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Add<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int 1<span style="color:#f92672">)))])]</span>
</code></pre></div><p>Excitingly enough, this is an AST that works for us. It properly represents what&rsquo;s going on in the code, and next we
can map it to real F# code so that it can properly function.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This blog post was written for <a href="https://sergeytihon.com/2020/10/22/f-advent-calendar-in-english-2020/">F# Advent 2020</a> and
it marks my first time participating in what I believe is a wonderful tradition. I hope that those who read it find it
helpful and interesting, and that those who are itching for more will anticipate the next post in the series in which
we&rsquo;ll be implementing an interpreter to go along with this parser. If you&rsquo;d like to see me implement the interpreter live,
I regularly stream what I&rsquo;m programming to <a href="https://twitch.tv/rosalogia">Twitch</a> with nothing but videogame music as background
noise, so you can easily tune in while doing other things. I appreciate the F# community and the work they&rsquo;ve put into making
the language and its ecosystem better, and I&rsquo;m more than happy to be contributing to it with this post!</p>
<h2 id="errata">Errata</h2>
<p>It&rsquo;s more than likely that I&rsquo;ve made an error here or there throughout this post, and if you find one I encourage you to reach
out to me so I can fix it and prevent future readers from being frustrated or mislead! You can contact me at
<a href="mailto:ambika.eshwar@rutgers.edu">ambika.eshwar@rutgers.edu</a> or create an issue on the GitHub repository containing
the source code for this tutorial, which will be available soon! Thanks to those of you who take the time to read this
post, and thanks again to the wonderful F# community who make F# nicer to use by the day by organising communal efforts like
F# advent!</p>

      </div>
    </article>

    <hr />

    <div class="post-info">
        <p>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
            <line x1="7" y1="7" x2="7" y2="7"></line>
          </svg><span class="tag"><a href="tags/functional-programming/">functional-programming</a></span><span class="tag"><a href="tags/fsharp/">fsharp</a></span><span class="tag"><a href="tags/dotnet/">dotnet</a></span><span class="tag"><a href="tags/fparsec/">fparsec</a></span>
        </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        4375 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        2020-12-02 05:09 -0500
      </p>
    </div>
      <hr />
      <div class="sharing-buttons">
        
<a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2ffunctional-parsing%2f" target="_blank" rel="noopener" aria-label="" title="Share on facebook">
  <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?url=%2fposts%2ffunctional-parsing%2f" target="_blank" rel="noopener" aria-label="" title="Share on twitter">
  <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small">
      <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.tumblr.com/widgets/share/tool?posttype=link&amp;title=Parsing%20Programming%20Languages%20with%20FParsec&amp;caption=Parsing%20Programming%20Languages%20with%20FParsec&amp;canonicalUrl=%2fposts%2ffunctional-parsing%2f" target="_blank" rel="noopener" aria-label="" title="Share on tumblr">
  <div class="resp-sharing-button resp-sharing-button--tumblr resp-sharing-button--small">
    <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.563 24c-5.093 0-7.031-3.756-7.031-6.411V9.747H5.116V6.648c3.63-1.313 4.512-4.596 4.71-6.469C9.84.051 9.941 0 9.999 0h3.517v6.114h4.801v3.633h-4.82v7.47c.016 1.001.375 2.371 2.207 2.371h.09c.631-.02 1.486-.205 1.936-.419l1.156 3.425c-.436.636-2.4 1.374-4.156 1.404h-.178l.011.002z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="mailto:?subject=Parsing%20Programming%20Languages%20with%20FParsec&amp;body=%2fposts%2ffunctional-parsing%2f" target="_self" rel="noopener" aria-label="" title="Share via email">
  <div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://pinterest.com/pin/create/button/?url=%2fposts%2ffunctional-parsing%2f&amp;media=%2fposts%2ffunctional-parsing%2f;description=Parsing%20Programming%20Languages%20with%20FParsec" target="_blank" rel="noopener" aria-label="" title="Share on pinterest">
  <div class="resp-sharing-button resp-sharing-button--pinterest resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.162-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.099.12.112.225.085.345-.09.375-.293 1.199-.334 1.363-.053.225-.172.271-.401.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.354-.629-2.758-1.379l-.749 2.848c-.269 1.045-1.004 2.352-1.498 3.146 1.123.345 2.306.535 3.55.535 6.607 0 11.985-5.365 11.985-11.987C23.97 5.39 18.592.026 11.985.026L12.017 0z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fposts%2ffunctional-parsing%2f&amp;title=Parsing%20Programming%20Languages%20with%20FParsec&amp;summary=Parsing%20Programming%20Languages%20with%20FParsec&amp;source=%2fposts%2ffunctional-parsing%2f" target="_blank" rel="noopener" aria-label="" title="Share on linkedin">
  <div class="resp-sharing-button resp-sharing-button--linkedin resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://reddit.com/submit/?url=%2fposts%2ffunctional-parsing%2f&amp;resubmit=true&amp;title=Parsing%20Programming%20Languages%20with%20FParsec" target="_blank" rel="noopener" aria-label="" title="Share on reddit">
  <div class="resp-sharing-button resp-sharing-button--reddit resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://www.xing.com/app/user?op=share;url=%2fposts%2ffunctional-parsing%2f;title=Parsing%20Programming%20Languages%20with%20FParsec" target="_blank" rel="noopener" aria-label="" title="Share on xing">
  <div class="resp-sharing-button resp-sharing-button--xing resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="whatsapp://send?text=Parsing%20Programming%20Languages%20with%20FParsec%20%2fposts%2ffunctional-parsing%2f" target="_blank" rel="noopener" aria-label="" title="Share on whatsapp">
  <div class="resp-sharing-button resp-sharing-button--whatsapp resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://news.ycombinator.com/submitlink?u=%2fposts%2ffunctional-parsing%2f&amp;t=Parsing%20Programming%20Languages%20with%20FParsec" target="_blank" rel="noopener" aria-label="" title="Share on hacker news">
  <div class="resp-sharing-button resp-sharing-button--hackernews resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M0 24V0h24v24H0zM6.951 5.896l4.112 7.708v5.064h1.583v-4.972l4.148-7.799h-1.749l-2.457 4.875c-.372.745-.688 1.434-.688 1.434s-.297-.708-.651-1.434L8.831 5.896h-1.88z"/></svg>
    </div>
  </div>
</a>


<a class="resp-sharing-button__link" href="https://telegram.me/share/url?text=Parsing%20Programming%20Languages%20with%20FParsec&amp;url=%2fposts%2ffunctional-parsing%2f" target="_blank" rel="noopener" aria-label="" title="Share on telegram">
  <div class="resp-sharing-button resp-sharing-button--telegram resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
    </div>
  </div>
</a>

      </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h">Read other posts</span>
          <hr />
        </div>

        <div class="pagination__buttons">
          

          
            <span class="button next">
              <a href="/posts/configuring-saturn-to-use-postgres/">
                <span class="button__text">Configuring Saturn to Use Postgres</span>
                <span class="button__icon">â†’</span>
              </a>
            </span>
          
        </div>
      </div>
    


    
      
        <div id="comments">
          <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "rosalogia" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
      
    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            
            
                <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            
            <span> <a href="posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
          </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.a0f363fdf81cdc5cfacc447a79c33189eb000d090336cd04aac8ee256f423b3133b836c281944c19c75e38d0b0b449f01ce5807e37798b7ac94ac1db51983fc4.js" integrity="sha512-oPNj/fgc3Fz6zER6ecMxiesADQkDNs0EqsjuJW9COzEzuDbCgZRMGcdeONCwtEnwHOWAfjd5i3rJSsHbUZg/xA=="></script>



    </body>
</html>
