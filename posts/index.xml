<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Ambika Eshwar</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Ambika Eshwar</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 02 Dec 2020 05:09:00 -0500</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Parsing Programming Languages with FParsec</title>
            <link>/posts/functional-parsing/</link>
            <pubDate>Wed, 02 Dec 2020 05:09:00 -0500</pubDate>
            
            <guid>/posts/functional-parsing/</guid>
            <description>Over the past few months, after learning about parser combinators in Joachim Breitner&amp;rsquo;s Haskell course, I&amp;rsquo;ve found myself needing or wanting to approach a problem by writing a parser more often than I had ever expected to. Each time, I&amp;rsquo;m amazed and satisfied by the simplicity and declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting and much less repetitive.</description>
            <content type="html"><![CDATA[<p>Over the past few months, after learning about parser combinators in Joachim Breitner&rsquo;s
<a href="https://www.seas.upenn.edu/~cis194/fall16/">Haskell course</a>, I&rsquo;ve found myself needing or wanting to approach a problem
by writing a parser more often than I had ever expected to. Each time, I&rsquo;m amazed and satisfied by the simplicity and
declarativity of parser-combinators. Not only does the functional pattern of combinator functions result in clean and
readable code (except for mystical operators here and there), I find that it also makes solving problems much more interesting
and much less repetitive.</p>
<p>My first use-case for parser-combinators outside of the aforementioned Haskell course was parsing a &ldquo;pseudocode&rdquo; language
used by my university to teach the first few weeks of our intro CS course. The irony in this &ldquo;pseudocode&rdquo; was that its syntax
was so strictly defined that it sort of transcended its label, and I figured I&rsquo;d be able to create a parser that successfully
transformed correct &ldquo;pseudocode&rdquo; into an AST. Once I finished writing a parser, I figured it wouldn&rsquo;t be too difficult to
implement an interpreter as well, and indeed this too was within reach. I enjoyed the project a lot, and in this post and
the post that will follow (in which we will implement an interpreter), I wanted to share the process as a more exciting and
slightly more challenging alternative to the typical JSON parsing tutorial that most parser-combinators already have.</p>
<p>Note that the language we will be writing a parser for in this post is a language of our own creation! If you disagree with
me on how the syntax of the language should appear and feel confident enough in your understanding of parser-combinators,
feel free to experiment and create a language syntax that&rsquo;s more akin to your preferences. Another thing to note is that this tutorial
is not quite suited to those who are unfamiliar with F# and functional programming. I would also recommend doing some more basic
reading on parser-combinators before approaching this post, as I try not to spend time on what they are but rather on explaining
how they can be used in a cool way. The FParsec documentation&rsquo;s tutorial is very good and very helpful, as is Scott Wlaschin&rsquo;s
series on <a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Understanding Parser Combinators</a>.</p>
<h2 id="representing-an-ast">Representing an AST</h2>
<p>The goal of a parser is to give structure and meaning to the information it receives. When dealing with source code for
programming languages, we often want to give structure and meaning to code by translating it into an &ldquo;abstract syntax tree.&rdquo;
Modelling an AST in F# is pretty easy using Algebraic Data Types. We simply need to create types and constructors that
correspond to every type of thing that the source code for a program in our language might contain.</p>
<p>A good place to start in representing the syntax of our language is values, such as integers, strings, and booleans. In this
series of posts, we will make it our goal to be able to parse and eventually interpret an implementation of FizzBuzz
in our language, but not much more. For this reason, we will not be concerned with parsing floating point numbers, arrays,
etc. Integers, strings, and booleans will do.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Value</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Int <span style="color:#66d9ef">of</span> int
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Str <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Bool <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">bool</span>
</span></span></code></pre></div><p>From this point on, we are &ldquo;thinking upwards.&rdquo; Once we have succeeded in representing one foundational structure, we can ask
ourselves what kinds of structures we&rsquo;ve enabled ourselves to represent by defining this one. Now that we have a way to represent
values in our AST, we might want to represent expressions as well. The various forms that expressions take in most programming
languages tend to be:</p>
<ul>
<li>Literals (values)</li>
<li>Variables (which evaluate down to values)</li>
<li>Operations (which chain together expressions and ultimately evaluate down to values)</li>
</ul>
<p>Defining values gives us a way to represent both literals and variables, but to represent operations we need a way to represent
operators as well. Before creating an Expression type, we will define an Operator type like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Operator</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Add <span style="color:#75715e">// Arithmetic operators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Sub
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Mult
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Div
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Mod
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Gt <span style="color:#75715e">// Comparison operators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Lt
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Gte
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Lte
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Eq <span style="color:#75715e">// Equality operators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Neq
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> And <span style="color:#75715e">// Boolean operators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Or
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Sconcat <span style="color:#75715e">// String concatenation
</span></span></span></code></pre></div><p>And now, we can define an <code>Expr</code> type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Expr</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Literal <span style="color:#66d9ef">of</span> Value
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Variable <span style="color:#66d9ef">of</span> name<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The Expr type is recursive, as operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// can consist of expressions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Operation <span style="color:#66d9ef">of</span> <span style="color:#f92672">(</span>Expr <span style="color:#f92672">*</span> Operator <span style="color:#f92672">*</span> Expr<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Believe it or not, we are almost done building types to represent our AST. All that&rsquo;s left is a type to represent <em>statements</em>.
Because all we are aiming to do with this language is parse and interpret FizzBuzz, we will avoid implementing functions in our
language and will only implement some of the most basic imperative constructs:</p>
<ul>
<li>Printing output</li>
<li>Assigning values to variables</li>
<li>If/Else conditionals</li>
<li>While loops</li>
</ul>
<p>This will make for a very simple language, but we will be able to do some fun things with it once we&rsquo;re done. We can
represent statements by pairing them with the information they need to execute. E.g. Print requires an expression to output,
Set (as in set equal to) requires a variable name and an expression to pair that name with, etc.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Statement</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Print <span style="color:#66d9ef">of</span> Expr
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Set <span style="color:#66d9ef">of</span> name<span style="color:#f92672">:</span><span style="color:#66d9ef">string</span> <span style="color:#f92672">*</span> value<span style="color:#f92672">:</span>Expr
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> If <span style="color:#66d9ef">of</span> condition<span style="color:#f92672">:</span>Expr <span style="color:#f92672">*</span> body<span style="color:#f92672">:</span>Block <span style="color:#f92672">*</span> <span style="color:#66d9ef">else</span><span style="color:#f92672">:</span>Block option
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> While <span style="color:#66d9ef">of</span> condition<span style="color:#f92672">:</span>Expr <span style="color:#f92672">*</span> body<span style="color:#f92672">:</span>Block
</span></span><span style="display:flex;"><span><span style="color:#f92672">and</span> Block <span style="color:#f92672">=</span> Statement <span style="color:#66d9ef">list</span>
</span></span></code></pre></div><p>We have defined a Block type in a mutually recursive fashion with the Statement type to represent lists of statements, which
constitute the bodies of ifs and whiles in our AST, as well as our program as a whole.</p>
<p>With these types defined, we can begin writing parsers that will output values of these types, and eventually we can
write a program that executes certain instructions based on data that comes in the form of an AST.</p>
<h2 id="parsing">Parsing</h2>
<h3 id="values">Values</h3>
<p>Now that we have a meaningful way to represent parsed source code, we can begin writing parsers that output values
of the types in our AST representation.</p>
<p>I like to start by defining some convenient combinators which I use frequently that FParsec doesn&rsquo;t provide on its own.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pword s <span style="color:#f92672">=</span> pstring s <span style="color:#f92672">.&gt;&gt;</span> spaces
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A combinator that transforms a parser by requiring that it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// be wrapped in parentheses
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> parens p <span style="color:#f92672">=</span> between <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;(&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;)&#34;</span><span style="color:#f92672">)</span> p
</span></span></code></pre></div><p>The <code>.&gt;&gt;</code> operator returns the result of the parser on the left and discards the result of the parser on the right.</p>
<p>Now we can slowly begin implementing parsers for all the things in our AST, beginning with Values which may be
integers, strings, or booleans.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pbool<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    pword <span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#f92672">&lt;|&gt;</span> pword <span style="color:#e6db74">&#34;false&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;&gt;</span> <span style="color:#66d9ef">function</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#f92672">-&gt;</span> Bool <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;false&#34;</span> <span style="color:#f92672">-&gt;</span> Bool <span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FParsec defines the pint32 parser.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// We simply cast its result to an int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// then construct an Integer Value from it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> pint<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> pint32 <span style="color:#f92672">|&gt;&gt;</span> int <span style="color:#f92672">|&gt;&gt;</span> Int
</span></span></code></pre></div><p>The <code>&lt;|&gt;</code> operator is the &ldquo;or&rdquo; operator. If the parser on the left fails, it will use the parser on the right instead. If both
fail, we get a parsing error. Whether the parsed string is &ldquo;true&rdquo; or &ldquo;false&rdquo;, we can easily pass it to our value constructor to
convert it to a Bool Value. When we want to try several parsers, using the <code>&lt;|&gt;</code> operator can become inconvenient. In those
situations, the <code>choice</code> combinator exists, and operates on a list of parsers of the same type. We will see how it&rsquo;s useful later,
but know that we could have just as well done <code>choice [ pword &quot;true&quot; ; pword &quot;false&quot; ]</code> to achieve the same effect as using the
&ldquo;or&rdquo; operator here.</p>
<p>The <code>|&gt;&gt;</code> operator lets us pipe the result of our parser to a function that normally operates on the type of our result,
then returns whatever value it produces into a Parser value. In this case, we have to pipe the result of parsing the string
&ldquo;true&rdquo; or &ldquo;false&rdquo; to a pattern match where we match each string to a corresponding Bool Value.</p>
<p>Note that when we use parser-combinators, we do not actually receive values in their original or &ldquo;regular&rdquo; types until we finally run our
parser with a variant of the <code>run</code> function defined by FParsec. Until then, you will notice that our values are always in
the form <code>Parser&lt;Type, Unit&gt;</code>. This is done in accordance with a functional design pattern that
<a href="https://fsharpforfunandprofit.com/posts/elevated-world/">Scott Wlaschin</a> explains more carefully on his site than I can in
this post.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pstringliteral<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This line returns a list of chars, which we have to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// turn into a string before turning into a Str Value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pchar <span style="color:#e6db74">&#39;\&#34;&#39;</span> <span style="color:#f92672">&gt;&gt;.</span> manyCharsTill anyChar <span style="color:#f92672">(</span>pchar <span style="color:#e6db74">&#39;\&#34;&#39;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;&gt;</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">|&gt;&gt;</span> Str
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Discard the spaces at the end
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">.&gt;&gt;</span> spaces
</span></span></code></pre></div><p>In order to parse any sequence of characters between a pair of quotes, we first parse the opening quote and discard it, then
use the <code>manyCharsTill</code> combinator to parse all the remaining characters up until the closing quote (which is discarded).</p>
<p>Note that the <code>&gt;&gt;.</code> operator is very similar to the <code>.&gt;&gt;</code> operator. In this case, the value on the left of the operator is
discarded. A good way to think about it is that whatever is on the side of the <code>.</code> is what gets kept. The operators <code>&gt;&gt;</code> and
<code>.&gt;&gt;.</code> also exist, for when you only want to discard twice in a row or when you want to keep two parsed values in a row, in which
case you&rsquo;ll receive a tuple.</p>
<p><code>manyCharsTill</code> takes two parsers. The former is run until the latter is eventually matched, at which point it stops.</p>
<p>Now that we have defined parsers for the three types of values that might be represented in our AST, we want to create
a <code>pvalue</code> parser that combines all three of them. To do this, we will use <code>choice</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pvalue<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Value<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>        pint
</span></span><span style="display:flex;"><span>        pstringliteral
</span></span><span style="display:flex;"><span>        pbool
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">]</span>
</span></span></code></pre></div><h4 id="running-and-testing-parsers">Running and Testing Parsers</h4>
<p>As we work on our parser, it&rsquo;s a good idea to test the parsers you build individually as you progress. The easiest way
to do this is to create a console application that references FParsec and uses the provided <code>run</code> function on a parser
and a string. Be aware that it returns a result type, so you can define a test function like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> test parser strInput <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> run parser strInput <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Assuming your parser returns something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// that can be printed. For our purposes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// %O is usually enough. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">|</span> Success <span style="color:#f92672">(</span>result<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%O&#34;</span> result
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Failure <span style="color:#f92672">(</span>error<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%s&#34;</span> error
</span></span></code></pre></div><p>Also be aware that FParsec&rsquo;s parsing errors are extremely informative and helpful!</p>
<h3 id="expressions">Expressions</h3>
<p>Going in the same order in which we defined types in our AST representation, we now want to implement expression parsers
that make use of our value parser.</p>
<p>We can easily start by writing a parser for <code>Literal</code>s, since all they require is a <code>Value</code> which we can already parse.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pliteral<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> pvalue <span style="color:#f92672">|&gt;&gt;</span> Literal
</span></span></code></pre></div><p>Writing a variable parser is slightly more difficult, but the implementation is largely up to us. I have chosen to make
valid variable names begin with letters and contain either letters or numbers. We can implement this rule using the
<code>many1Satisfy2</code> combinator which takes two predicates and parses as many characters as possible so long as</p>
<ul>
<li>The first char must satisfy the first predicate</li>
<li>The remaining chars must satisfy the second predicate</li>
</ul>
<p>Using this convenient combinator, we can write a variable parser that implements the rule above like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pvariable<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    many1Satisfy2 <span style="color:#f92672">(</span>System.Char.IsLetter<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>System.Char.IsLetterOrDigit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;&gt;</span> Variable
</span></span><span style="display:flex;"><span>    .<span style="color:#f92672">&gt;&gt;</span> spaces
</span></span></code></pre></div><p>The most difficult and convoluted parser to implement is the operation parser. FParsec provides some convenient utilities
to make this task less difficult, but ultimately it is still rather tedious. FParsec includes the
<a href="https://www.quanttec.com/fparsec/reference/operatorprecedenceparser.html#members.OperatorPrecedenceParser"><code>OperatorPrecedenceParser</code></a>
class. This allows us to define a parser for each &ldquo;term&rdquo; of an operation, define operators themselves according to their symbol,
associativity, precedence, and how the parser should handle them, and in return get an operation parser handed to us for a given
type. This is extremely convenient, whereas implementing operator parsing on our own would&rsquo;ve been rather difficult.</p>
<p>Let&rsquo;s begin configuring an <code>OperatorPrecedenceParser</code> for integers, beginning by initialising one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> intOperatorParser <span style="color:#f92672">=</span> OperatorPrecedenceParser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
</span></span></code></pre></div><p>Every OperatorPrecedenceParser has an expression parser that gets updated as we further define the OperatorPrecedenceParser by
giving it a term parser and operators to operate on those terms. If at any point we want to parse an operation between two
integers, we will use this parser.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> intExpr <span style="color:#f92672">=</span> intOperatorParser<span style="color:#f92672">.</span>ExpressionParser
</span></span></code></pre></div><p>We define the parser for an int &ldquo;term&rdquo;, that is, something that lies on either side of an integer operation (which may be an
integer operation itself, which is why we refer to the intexpr parser in our term parser)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> intTerm <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    pint <span style="color:#f92672">.&gt;&gt;</span> spaces <span style="color:#f92672">|&gt;&gt;</span> Literal <span style="color:#f92672">&lt;|&gt;</span> pvariable
</span></span><span style="display:flex;"><span>    parens intExpr
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Assign the term parser we designed to the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// OperatorPrecedenceParser instance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>intOperatorParser<span style="color:#f92672">.</span>TermParser <span style="color:#f92672">&lt;-</span> intTerm
</span></span></code></pre></div><p>The <code>OperatorPrecedenceParser</code> class has an <code>AddOperator</code> method to which we can pass an <code>InfixOperator</code> object (a class also
defined by FParsec) that takes as input the following:</p>
<ul>
<li>A string symbol representing the operator</li>
<li>A parser to run after consuming the operator (usually a white-space parser)</li>
<li>The relative precedence level of the operator as an integer</li>
<li>The associativity of the operator (FParsec provides an Associativity type with constructors Left and Right)</li>
<li>A function that takes two terms and returns a term <code>('TTerm -&gt; 'TTerm -&gt; 'TTerm)</code></li>
</ul>
<p>It can be a little difficult to know how to create every operator we need using this constructor. One thing to note is that
the function that the <code>InfixOperator</code> constructor takes, known as a mapping, will not actually apply an operation to two
terms in our case. Since we are only parsing here, we will take two <code>Expr</code>s in our mapping and return an <code>Operation</code>, which
works because <code>Operation</code>s are <code>Expr</code>s, as are variables and literals. This is, in fact, so simple that it does not need
to change much at all between operators. We can write a simple function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> createOperation op x y <span style="color:#f92672">=</span> Operation <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> op<span style="color:#f92672">,</span> y<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Which we can later partially apply to an <code>Operator</code> to define our mapping. Here is an example of how creating an <code>InfixOperator</code>
might work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> addition <span style="color:#f92672">=</span> InfixOperator<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;+&#34;</span><span style="color:#f92672">,</span> spaces<span style="color:#f92672">,</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">,</span> Associativity.Left<span style="color:#f92672">,</span> createOperation Add<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>intOperatorParser<span style="color:#f92672">.</span>AddOperator<span style="color:#f92672">(</span>addition<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Now, when the <code>intExpr</code> parser is applied to a string like <code>1 + 3</code>, the AST representation will look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span>Operation <span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>    Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">1</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>    Add<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>    Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">3</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Which we can easily work with later in the interpreting phase.</p>
<p>In order to minimise code repetition, we can employ the following pattern to quickly create and add all the operators we need
for integers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">OperatorDetails</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>  Symbol<span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                          Precedence<span style="color:#f92672">:</span> int<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                          Operator<span style="color:#f92672">:</span> Operator <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> intOperators <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;+&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Add<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&gt;&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Gt<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Lt<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&gt;=&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Gte<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&lt;=&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Lte<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;==&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Eq<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;!=&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Neq<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;+&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Add<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Sub<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;*&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Mult<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Div<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;%&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Mod<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> addOperators precedenceParser operatorTable <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    operatorTable
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;</span> List.iter <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> details <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> operator <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>          InfixOperator<span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>              details<span style="color:#f92672">.</span>Symbol<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>              spaces<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>              details<span style="color:#f92672">.</span>Precedence<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>              Associativity.Left<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>              createOperation details<span style="color:#f92672">.</span>Operator
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        precedenceParser<span style="color:#f92672">.</span>AddOperator<span style="color:#f92672">(</span>operator<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>addOperators intOperatorParser intOperators
</span></span></code></pre></div><p>We create a small table of operators for integers, then define a function that iterates over the table and adds each operator
to its <code>OperatorPrecedenceParser</code>. This is a relatively neat way to do what becomes rather ugly otherwise. We need to do the same
thing for strings and booleans, but they have far fewer operations defined over them, so we have slightly less to worry about.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// Define similar structures for booleans and strings
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> boolOperatorParser <span style="color:#f92672">=</span> OperatorPrecedenceParser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> boolExpr <span style="color:#f92672">=</span> boolOperatorParser<span style="color:#f92672">.</span>ExpressionParser
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> boolTerm <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    pboolval <span style="color:#f92672">.&gt;&gt;</span> spaces <span style="color:#f92672">|&gt;&gt;</span> Literal
</span></span><span style="display:flex;"><span>    pvariable
</span></span><span style="display:flex;"><span>    parens boolExpr
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>boolOperatorParser<span style="color:#f92672">.</span>TermParser <span style="color:#f92672">&lt;-</span> boolTerm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> strOperatorParser <span style="color:#f92672">=</span> OperatorPrecedenceParser<span style="color:#f92672">&lt;</span>Expr<span style="color:#f92672">,</span> Unit<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> strExpr <span style="color:#f92672">=</span> strOperatorParser<span style="color:#f92672">.</span>ExpressionParser
</span></span><span style="display:flex;"><span><span style="color:#75715e">// We want to make sure we can concatenate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// non-string values with strings, so we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// accept any literal or variable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> strTerm <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    pliteral
</span></span><span style="display:flex;"><span>    pvariable
</span></span><span style="display:flex;"><span>    intExpr
</span></span><span style="display:flex;"><span>    boolExpr
</span></span><span style="display:flex;"><span>    parens strExpr 
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>strOperatorParser<span style="color:#f92672">.</span>TermParser <span style="color:#f92672">&lt;-</span> strTerm
</span></span></code></pre></div><p>Now we define their operator tables and add those operators with <code>List.iter</code> as we did for integers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> boolOperators <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;and&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span>  And<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;or&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Or<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> stringOperators <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>Symbol <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;++&#34;</span><span style="color:#f92672">;</span> Precedence <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> Operator <span style="color:#f92672">=</span> Sconcat<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>addOperators boolOperatorParser boolOperators
</span></span><span style="display:flex;"><span>addOperators strOperatorParser stringOperators
</span></span></code></pre></div><p>Now we have a parser for every type of operation, we can define an operation parser much like we defined a value parser earlier:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> poperation <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    intExpr
</span></span><span style="display:flex;"><span>    boolExpr
</span></span><span style="display:flex;"><span>    strExpr
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>And now, since we have a literal parser, a variable parser, and an operation parser, we can define an expression parser:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pexpression <span style="color:#f92672">=</span> choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    poperation
</span></span><span style="display:flex;"><span>    pliteral
</span></span><span style="display:flex;"><span>    pvariable
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>We can finally move on to parsing statements.</p>
<h3 id="statements">Statements</h3>
<p>Something to note before we get started implementing statement parsers is that the <code>Statement</code> type is recursive. The
<code>Expr</code> type is also recursive, but we handled that with the <code>OperatorPrecedenceParser</code> class given to us by FParsec.
The <code>Statement</code> class is recursive because <code>If</code> blocks and <code>While</code> loops must contain statements themselves to be useful.
We will find that before we can create a <code>pstatement</code> parser the way we did with <code>pvalue</code> and <code>poperation</code>, we will need
access to a <code>pstatement</code> parser for use in defining the parsers for if and while. FParsec offers a solution for this as well,
as recursive parsers aren&rsquo;t awfully uncommon.</p>
<p>The solution is the <code>createParserForwardedToRef</code> function, which takes advantage of F#&rsquo;s multi-paradigm nature to simplify
the handling of recursive parsers. Of course, it&rsquo;s all abstracted rather well, so we don&rsquo;t need to worry too much about how
it&rsquo;s implemented to make good use of it. Before we begin implementing statement parsers, we will create the <code>pstatement</code>
parser like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pstatement<span style="color:#f92672">,</span> pstatementref <span style="color:#f92672">=</span> createParserForwardedToRef<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span>()
</span></span></code></pre></div><p>Later on, when we wish to parse a statement within a statement parser, we can use <code>pstatement</code>.</p>
<p>Let&rsquo;s parse all our statements in order, starting with print:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pprint<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    pword <span style="color:#e6db74">&#34;print&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;&gt;.</span> parens pexpression
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;&gt;</span> Print
</span></span></code></pre></div><p>We&rsquo;re able to use the <code>&gt;&gt;.</code> operator in conjunction with the <code>parens</code> combinator we defined earlier to parse out the expression
within a <code>print(...)</code> statement and pass it to the <code>Print</code> constructor.</p>
<p>Next we&rsquo;ll implement <code>Set</code> which parses variable assignment:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pset<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> identifier <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        many1Skip2 <span style="color:#f92672">(</span>System.Char.IsLetter<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>System.Char.IsLetterOrDigit<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">.&gt;&gt;</span> pword <span style="color:#e6db74">&#34;=&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    identifier <span style="color:#f92672">.&gt;&gt;.</span> pexpression
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;&gt;</span> Set
</span></span></code></pre></div><p>Here we define an <code>identifier</code> parser that parses valid names of variables before an equals sign (which gets discarded),
then make use of the <code>.&gt;&gt;.</code> operator to parse both an identifier and an expression and pass the resulting tuple to the <code>Set</code>
constructor.</p>
<p>Before we move on, we&rsquo;ll define a parser called <code>pblock</code> which parses blocks of code between curly braces:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pblock<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement <span style="color:#66d9ef">list</span><span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    between <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;{&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>pword <span style="color:#e6db74">&#34;}&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>many pstatement<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Now we can define parsers for if and while:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pif<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> condition <span style="color:#f92672">=</span> pword <span style="color:#e6db74">&#34;if&#34;</span> <span style="color:#f92672">&gt;&gt;.</span> pexpression
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> inner <span style="color:#f92672">=</span> pblock
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> elseBlock <span style="color:#f92672">=</span> pword <span style="color:#e6db74">&#34;else&#34;</span> <span style="color:#f92672">&gt;&gt;.</span> pblock <span style="color:#f92672">|&gt;</span> opt
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    pipe3 condition inner elseBlock <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> condition inner elseBlock <span style="color:#f92672">-&gt;</span> If <span style="color:#f92672">(</span>condition<span style="color:#f92672">,</span> inner<span style="color:#f92672">,</span> elseBlock<span style="color:#f92672">))</span>
</span></span></code></pre></div><p>In the if parser, we first parse a condition by parsing out the &ldquo;if&rdquo; then disposing of it, and keeping the valid expression
that follows. We use <code>pblock</code> to parse the body of the if, and we use FParsec&rsquo;s <code>opt</code> to optionally parse an else block as well.
If there is no else block, this parser returns <code>None</code> which we pass to the <code>If</code> constructor. The parser gets a little ugly
toward the end because we need to use <code>pipe3</code>. Unfortunately there is no operator in FParsec that conveniently performs
the same task as <code>.&gt;&gt;.</code> but returning a triple rather than a tuple. Instead, we must use <code>pipe3</code> which applies 3 given
parsers in order, and then pipes their results to a function that takes 3 inputs. Here we use <code>pipe3</code> to pipe the condition,
if body, and potentially existing else block to the <code>If</code> constructor.</p>
<p>Thankfully, the while parser is much nicer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> pwhile<span style="color:#f92672">:</span> Parser<span style="color:#f92672">&lt;</span>Statement<span style="color:#f92672">,</span> Unit<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> condition <span style="color:#f92672">=</span> pword <span style="color:#e6db74">&#34;while&#34;</span> <span style="color:#f92672">&gt;&gt;.</span> pexpression
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    condition <span style="color:#f92672">.&gt;&gt;.</span> pblock
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|&gt;&gt;</span> While
</span></span></code></pre></div><p>We use the same parsing strategy we employed for parsing the condition in the if parser here, while using the same <code>.&gt;&gt;.</code> strategy
for piping to the constructor that we used for <code>pset</code>.</p>
<p>We have now defined all of our statement parsers, but before we can progress, we must complete one last step required by the
<code>pstatement</code> parser that was forwarded to a reference cell. Similar to how we created the <code>pvalue</code> and <code>pexpression</code> parsers,
we assign a <code>choice</code> of the statement parsers we&rsquo;ve written to the <code>pstatementref</code> that was created when we initialised the
<code>pstatement</code> parser:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">do</span> pstatementref <span style="color:#f92672">:=</span> choice <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    pprint
</span></span><span style="display:flex;"><span>    pif
</span></span><span style="display:flex;"><span>    pwhile
</span></span><span style="display:flex;"><span>    pset
</span></span><span style="display:flex;"><span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>Do not worry if this step confuses you. This quote from the FParsec documentation&rsquo;s JSON parsing tutorial helps demystify it
a little bit:</p>
<blockquote>
<p>The grammar rules for JSON lists and objects are recursive, because any list or object can contain itself any kind of JSON value. Hence, in order to write parsers for the list and object grammar rules, we need a way to refer to the parser for any kind of JSON value, even though we haven’t yet constructed this parser. Like it is so often in computing, we can solve this problem by introducing an extra indirection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> jvalue<span style="color:#f92672">,</span> jvalueRef <span style="color:#f92672">=</span> createParserForwardedToRef<span style="color:#f92672">&lt;</span>Json<span style="color:#f92672">,</span> <span style="color:#66d9ef">unit</span><span style="color:#f92672">&gt;</span>()
</span></span></code></pre></div><p>As you might have guessed from the name, <code>createParserForwardedToRef</code> creates a parser (jvalue) that forwards all invocations to the parser in a reference cell (jvalueRef). Initially, the reference cell holds a dummy parser, but since the reference cell is mutable, we can later replace the dummy parser with the actual value parser, once we have finished constructing it.</p>
</blockquote>
<p>You can read the full tutorial <a href="https://www.quanttec.com/fparsec/tutorial.html#parsing-json">here</a>.</p>
<h2 id="tying-it-all-together">Tying it All Together</h2>
<p>At this point we have implemented parsers for everything that appears in the set of types we created to represent our language&rsquo;s
AST. This means that we can write programs in the language we specified and run them through our parser to get an AST as output.
Later on, we can use this generated AST to map code in the source language to F# code to implement an interpreter. For now, let&rsquo;s
write a testing function that will allow us to see how far we&rsquo;ve come.</p>
<p>As explained at an earlier point, FParsec provides a <code>run</code> function and variants of it for running parsers. We specifically
want to run a parser on a file, and what we want to parse is as many statements as we can. FParsec provides a <code>runParserOnFile</code>
function, and we have built a statement parser which we can combine with the <code>many</code> combinator to achieve the effect we&rsquo;re looking
for:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> parseSourceFile fpath <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> runParserOnFile <span style="color:#f92672">(</span>many pstatement<span style="color:#f92672">)</span> () fpath System.Text.Encoding.UTF8 <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Success <span style="color:#f92672">(</span>result<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%A&#34;</span> result
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> Failure <span style="color:#f92672">(</span>error<span style="color:#f92672">,</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> printfn <span style="color:#e6db74">&#34;%s&#34;</span> error
</span></span></code></pre></div><p>Now we need a file to test this on. As promised, a FizzBuzz implementation will do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">100</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">15</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;fizzbuzz&#34;</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;fizz&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">&#34;buzz&#34;</span>)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                print(i)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running your parser on this file should result in something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#f92672">[</span>Set <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">1</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span> While
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Lte<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">100</span><span style="color:#f92672">)),</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">[</span>If
</span></span><span style="display:flex;"><span>       <span style="color:#f92672">(</span>Operation
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Mod<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">15</span><span style="color:#f92672">)),</span> Eq<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">0</span><span style="color:#f92672">)),</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Literal <span style="color:#f92672">(</span>Str <span style="color:#e6db74">&#34;fizzbuzz&#34;</span><span style="color:#f92672">))],</span>
</span></span><span style="display:flex;"><span>        Some
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">[</span>If
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">(</span>Operation
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Mod<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">3</span><span style="color:#f92672">)),</span> Eq<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                 Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">0</span><span style="color:#f92672">)),</span> <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Literal <span style="color:#f92672">(</span>Str <span style="color:#e6db74">&#34;fizz&#34;</span><span style="color:#f92672">))],</span>
</span></span><span style="display:flex;"><span>              Some
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">[</span>If
</span></span><span style="display:flex;"><span>                   <span style="color:#f92672">(</span>Operation
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">(</span>Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Mod<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">5</span><span style="color:#f92672">)),</span> Eq<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>                       Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">0</span><span style="color:#f92672">)),</span> <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Literal <span style="color:#f92672">(</span>Str <span style="color:#e6db74">&#34;buzz&#34;</span><span style="color:#f92672">))],</span>
</span></span><span style="display:flex;"><span>                    Some <span style="color:#f92672">[</span>Print <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">)])])]);</span>
</span></span><span style="display:flex;"><span>     Set <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Operation <span style="color:#f92672">(</span>Variable <span style="color:#e6db74">&#34;i&#34;</span><span style="color:#f92672">,</span> Add<span style="color:#f92672">,</span> Literal <span style="color:#f92672">(</span>Int <span style="color:#ae81ff">1</span><span style="color:#f92672">)))])]</span>
</span></span></code></pre></div><p>Excitingly enough, this is an AST that works for us. It properly represents what&rsquo;s going on in the code, and next we
can map it to real F# code so that it can properly function.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This blog post was written for <a href="https://sergeytihon.com/2020/10/22/f-advent-calendar-in-english-2020/">F# Advent 2020</a> and
it marks my first time participating in what I believe is a wonderful tradition. I hope that those who read it find it
helpful and interesting, and that those who are itching for more will anticipate the next post in the series in which
we&rsquo;ll be implementing an interpreter to go along with this parser. If you&rsquo;d like to see me implement the interpreter live,
I regularly stream what I&rsquo;m programming to <a href="https://twitch.tv/rosalogia">Twitch</a> with nothing but videogame music as background
noise, so you can easily tune in while doing other things. I appreciate the F# community and the work they&rsquo;ve put into making
the language and its ecosystem better, and I&rsquo;m more than happy to be contributing to it with this post!</p>
<h2 id="errata">Errata</h2>
<p>It&rsquo;s more than likely that I&rsquo;ve made an error here or there throughout this post, and if you find one I encourage you to reach
out to me so I can fix it and prevent future readers from being frustrated or mislead! You can contact me at
<a href="mailto:ambika.eshwar@rutgers.edu">ambika.eshwar@rutgers.edu</a> or create an issue on the GitHub repository containing
the source code for this tutorial, which will be available soon! Thanks to those of you who take the time to read this
post, and thanks again to the wonderful F# community who make F# nicer to use by the day by organising communal efforts like
F# advent!</p>
]]></content>
        </item>
        
        <item>
            <title>Configuring Saturn to Use Postgres</title>
            <link>/posts/configuring-saturn-to-use-postgres/</link>
            <pubDate>Sat, 12 Sep 2020 17:10:35 -0400</pubDate>
            
            <guid>/posts/configuring-saturn-to-use-postgres/</guid>
            <description>Saturn is a modern MVC-oriented web framework for F# built on .NET Core, making it a suitable option for cross-platform development and deployment on unix-like operating systems, which for me is a must. The F# community is really enthusiastic about a feature of the F# language and environment which they lovingly refer to as type providers. When it comes to type providers, the objective is usually to provide some kind of immediate and type-safe mapping between an external data source and your F# codebase.</description>
            <content type="html"><![CDATA[<p><a href="https://saturnframework.org/">Saturn</a> is a modern MVC-oriented web framework for F# built
on .NET Core, making it a suitable option for cross-platform development and deployment
on unix-like operating systems, which for me is a must. The F# community is really
enthusiastic about a feature of the F# language and environment which they lovingly
refer to as <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/">type providers</a>.
When it comes to type providers, the objective is usually to provide some kind of immediate
and type-safe mapping between an external data source and your F# codebase. This is immensely
convenient since in F#, as with any functional language, types are a major source of developer power.
Being able to generate types from structured external data for use within your F# code removes
a lot of the hassle and worry that might otherwise accompany any effort to access external data.</p>
<p>However, being a .NET language, for a long while much of the documentation and guidance online
for F# was oriented toward Windows and Visual Studio users. Although they were appealing, I had
a difficult time trying to make use of the SQL providers on Linux, and for a long while this turned me
away from attempting any web development in F#. Although I&rsquo;m sure the situation has improved on that
front, I decided to see how easy it would be to use PostgreSQL on Linux with Saturn compared to my
attempt to use it with <a href="https://suave.io/">Suave</a> in 2017. It didn&rsquo;t take very long, but for future
reference (for myself) I&rsquo;ve decided to lay out the process here.</p>
<h2 id="setting-up-a-saturn-project">Setting up a Saturn Project</h2>
<p>Saturn provides really convenient tooling for setting up your project. If you already have
.NET Core 3.1 installed, you can execute the following in a directory of your choice to get
a working project put together for you:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>dotnet new -i Saturn.Template
</span></span><span style="display:flex;"><span>mkdir SaturnSample <span style="color:#f92672">&amp;&amp;</span> cd SaturnSample
</span></span><span style="display:flex;"><span>dotnet new saturn -lang F#
</span></span><span style="display:flex;"><span>dotnet tool restore
</span></span><span style="display:flex;"><span>dotnet saturn gen Book Books id:string title:string author:string
</span></span></code></pre></div><p>Open the file <code>…/SaturnSample/src/SaturnSample/Router.fs</code> and add the specified line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// This is the part of the file you&#39;re editing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> browserRouter <span style="color:#f92672">=</span> router <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  not_found_handler <span style="color:#f92672">(</span>htmlView NotFound.layout<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  pipe_through browser
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  forward <span style="color:#e6db74">&#34;&#34;</span> defaultView
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// This is the line you&#39;re adding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  forward <span style="color:#e6db74">&#34;/books&#34;</span> Books.Controller.resource
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>These instructions are taken directly from the <a href="https://saturnframework.org/tutorials/how-to-start.html">How to Start</a>
guide provided in the Saturn documentation, and if you&rsquo;d like further information about what they do you should check
them out there. I excluded the migration and build steps, but that&rsquo;s because I want to change the project to
use PostgreSQL before we migrate and build. Know, however, that if you&rsquo;ve already migrated and built your project for
SQLite, the rest of this guide can still be followed exactly without any problems. Simple.Migrations will run the migration
again for PostgreSQL once you make the necessary changes.</p>
<h2 id="setting-up-a-postgresql-database-with-docker">Setting up a PostgreSQL Database with Docker</h2>
<p>Although it&rsquo;s not at all necessary that you use Docker for this, I prefer containerising my databases
especially for scrap projects like this. If you&rsquo;d like to set up a local bare-metal installation of
PostgreSQL, you are free to do so.</p>
<p>With Docker installed and the Docker service enabled, run the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker run --name your-container-name -e POSTGRES_PASSWORD<span style="color:#f92672">=</span>your_password -p 5432:5432 -d postgres
</span></span></code></pre></div><p>This will create a <code>-d</code>etached container named <code>your-container-name</code> with an environment variable <code>POSTGRES_PASSWORD</code> set
to <code>your_password</code>, mapping your local port <code>5432</code> to port <code>5432</code> in the container, and finally it will run <code>postgres</code>
within the container. If you want to be sure that it works, you can try connecting to it locally (if you have PostgreSQL
and subsequently <code>psql</code> installed):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>psql -h localhost -p <span style="color:#ae81ff">5432</span> postgres -U postgres -W <span style="color:#75715e"># You will be prompted for a password</span>
</span></span></code></pre></div><p>You should be met with the standard PostgreSQL prompt, connected to the database <code>postgres</code>, which you can quit with <code>\q</code>.</p>
<h2 id="adjusting-your-saturn-project-to-use-npgsql">Adjusting Your Saturn Project to Use Npgsql</h2>
<p>Before we adjust the code that sets up the database connection, we should add Npgsql as a dependency in our project.
The files we need to modify are the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>…/SaturnSample/paket.dependencies
</span></span><span style="display:flex;"><span>…/SaturnSample/paket.lock
</span></span><span style="display:flex;"><span>…/SaturnSample/src/Migrations/paket.references
</span></span><span style="display:flex;"><span>…/SaturnSample/src/SaturnSample/paket.references
</span></span></code></pre></div><p>To learn more about the different Paket files, what their unique purposes are and how they work together, you
can read about it <a href="https://fsprojects.github.io/Paket/">here</a>.</p>
<p>In <code>…/SaturnSample/paket.dependencies</code>, find the line where <code>Microsoft.Data.Sqlite</code> is listed (the entire line should
read <code>nuget Microsoft.Data.Sqlite</code>) and right above or below it, add the following line:</p>
<pre tabindex="0"><code>nuget Npgsql
</code></pre><p>In <code>…/SaturnSample/paket.lock</code>, beneath the line that reads <code>remote: https://api.nuget.org/v3/index.json</code>,
include the following line with the version of Npgsql you want to use. I&rsquo;m using the <a href="https://www.nuget.org/packages/Npgsql/">latest</a>
as of September 12th 2020:</p>
<pre tabindex="0"><code>Npgsql (4.1.4)
</code></pre><p>In <code>…/SaturnSample/src/Migrations/paket.references</code> and <code>…/SaturnSample/src/SaturnSample/paket.references</code>, simply
add a line:</p>
<pre tabindex="0"><code>Npgsql
</code></pre><p>You can include it above or beneath <code>Microsoft.Data.Sqlite</code>.</p>
<p>In the root directory of your project, run <code>dotnet restore</code> to install <code>Npgsql</code>.</p>
<h2 id="adjusting-the-migrations-code">Adjusting the Migrations Code</h2>
<p>Thankfully for us, we don&rsquo;t need to change much at all to make our project, by default configured for SQLite,
fully compatible with a PostgreSQL database.</p>
<p>Open up <code>…/SaturnSample/src/Migrations/Program.fs</code>. You should see the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> Program
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">open</span> System.Reflection
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">open</span> SimpleMigrations
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">open</span> Microsoft.Data.Sqlite
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">open</span> SimpleMigrations.DatabaseProvider
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">open</span> SimpleMigrations.Console
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[&lt;</span>EntryPoint<span style="color:#f92672">&gt;]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> main argv <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> assembly <span style="color:#f92672">=</span> Assembly.GetExecutingAssembly()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> db <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SqliteConnection <span style="color:#e6db74">&#34;DataSource=src/SaturnSample/database.sqlite&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> provider <span style="color:#f92672">=</span> SqliteDatabaseProvider<span style="color:#f92672">(</span>db<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> migrator <span style="color:#f92672">=</span> SimpleMigrator<span style="color:#f92672">(</span>assembly<span style="color:#f92672">,</span> provider<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> consoleRunner <span style="color:#f92672">=</span> ConsoleRunner<span style="color:#f92672">(</span>migrator<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    consoleRunner<span style="color:#f92672">.</span>Run<span style="color:#f92672">(</span>argv<span style="color:#f92672">)</span> <span style="color:#f92672">|&gt;</span> ignore
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>The only SQLite specific parts of this code are the following lines:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> db <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SqliteConnection <span style="color:#e6db74">&#34;DataSource=src/SaturnSample/database.sqlite&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> provider <span style="color:#f92672">=</span> SqliteDatabaseProvider<span style="color:#f92672">(</span>db<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Changing this is simple. Make sure you <code>open Npgsql</code> underneath or below <code>open Microsoft.Data.Sqlite</code>.
Once you&rsquo;ve done that, go ahead and make the following changes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// Change use db = new SqliteConnection &#34;...&#34; to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> db <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> NpgsqlConnection <span style="color:#e6db74">&#34;Host=localhost;Username=postgres;Password=your_password;Database=postgres&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Change let provider = SqliteDatabaseProvider(db) to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> provider <span style="color:#f92672">=</span> PostgresqlDatabaseProvider<span style="color:#f92672">(</span>db<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>One last change before we migrate and build our project: in <code>…/SaturnSample/src/SaturnSample/Program.fs</code>,
change the following line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fsharp" data-lang="fsharp"><span style="display:flex;"><span><span style="color:#75715e">// Change use_config (fun _ -&gt; {connectionString = &#34;DataSource=src/SaturnSample/database.sqlite&#34;} ) to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>use_config <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>connectionString <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Host=localhost;Username=postgres;Password=your_password;Database=postgres&#34;</span><span style="color:#f92672">}</span> <span style="color:#f92672">)</span>
</span></span></code></pre></div><p>This is not exactly necessary, as development time configuration has not fully been implemented to my knowledge, but if it
will be implemented in the near future, it&rsquo;s not a bad idea to have be prepared to take advantage of it.</p>
<p>Simple.Migrations only needs an initialised DatabaseProvider to work with, so all we had to do was make sure we created
and passed a PostgresqlDatabaseProvider instead of a SqliteDatabaseProvider, which we can do easily with Npgsql.</p>
<h1 id="migrating-and-building">Migrating and Building</h1>
<p>This is the easiest step. The following commands should successfully create a table for the <code>Book</code> model we generated
earlier, and then build and run your application:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>dotnet saturn migration
</span></span><span style="display:flex;"><span>dotnet fake build -t run
</span></span></code></pre></div><p>Once the project finishes building and running, you should be able to interact with the part you added at
<a href="https://localhost:8085/books">https://localhost:8085/books</a>.</p>
<p>Enjoy developing full-stack F# web applications on Linux with <a href="https://saturnframework.org">Saturn</a>!</p>
]]></content>
        </item>
        
    </channel>
</rss>
